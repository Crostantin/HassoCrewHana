FUNCTION "HT"."HASSO_CREW.CDA.Porting.Functions::TB_CDA_FOR_PAGAMENTI_2" ( ) 
RETURNS TABLE(
	--return_table_type
	BUKRS NVARCHAR(4),
	GJAHR DECIMAL(4,0),
	BELNR NVARCHAR(10),
	BUZEI DECIMAL(3,0),
	"ROWID" BIGINT,
	LIFNR NVARCHAR(10),
	BSCHL NVARCHAR(2),
	STATUS INTEGER,
	BLDAT DATE,
	NETDT DATE,
	DMSHB DECIMAL(38,2),
	WRSHB DECIMAL(38,2),
	VAL_PAGATO_ALLOCATO DECIMAL(38,2),
	VAL_PAGATO_ALLOCATO_GMP DECIMAL(38,2),
	VAL_PAGATO_ALLOCATO_LC DECIMAL(38,2),
	VAL_PAGATO_ALLOCATO_GMP_LC DECIMAL(38,2),
	DATA_PAGAMENTO DATE,
	ESERCIZIO_PAGAMENTO DECIMAL(4,0),
	DOCUMENTO_PAGAMENTO NVARCHAR(10),
	NUM_RIGA_PAGAMENTO DECIMAL(3,0),
	AUGBL NVARCHAR(10),
	AUGDT DATE,
	DATA_PAREGGIO DATE
	)
	
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER AS
BEGIN

/***************************** 
	Write your function logic
 *****************************/

WT_FOR_PASSO1 = select * from "_SYS_BIC"."HASSO_CREW.CDA.Porting.Views/CDA_TEST_1";
M_CHIAVE_CONTABILE = select * from "HT"."M_CHIAVE_CONTABILE_TMP";


 	--Individuiamo gli accrediti a Fornitore che elidono le fatture 
 	/**
	TMP_Passo2_Fatture_Elise = 
	select a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI
	from "_SYS_BIC"."HASSO_CREW.CDA.Porting.Views/CDA_TEST_1" a
	INNER join (
		select distinct BUKRS, AUGBL, AUGDT From "_SYS_BIC"."HASSO_CREW.CDA.Porting.Views/CDA_TEST_1" a
		where BSCHL in (11, 12)
		and AUGDT >'1900-01-01' --Sono le fatture associate correttamente ad un documento di pareggio
	) b
	on (a.BUKRS=b.BUKRS and a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT)
 **/
 
 TMP_Passo2_Fatture_Elise =
	 select
		 a.BUKRS,
		 a.GJAHR,
		 a.BELNR,
		 a.BUZEI,
		 2 AS "tmp" 
		from :WT_FOR_PASSO1 a 
		where BSCHL in (31,
		 21) 
		and AUGDT >'1900-01-01' 
		;
			
 	--Pagamenti
	-- sto assumendo che non posso avere righe uguali a parità di: 
	--	PARTITION BY  a.BUKRS, a.AUGBL, a.AUGDT, a.LIFNR ORDER BY a.BLDAT, a.BELNR, a.BUZEI
	TMP_Passo2_Pagamenti = 
		select 
		ROW_NUMBER() over (order by AUGBL, AUGDT, LIFNR, BUKRS, GJAHR, BELNR, BUZEI) as "ROWID",
		a.BSCHL,
		--Documenti di Pareggio
		AUGBL, AUGDT, LIFNR, 
		--Chiave contabile
		 a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI,
		 --Valori del pagamento
		DMSHB VAL_PAGAMENTO, WRSHB VAL_PAGAMENTO_LC, 
		--Running Sum
		SUM(A.DMSHB) OVER (PARTITION BY  a.BUKRS, a.AUGBL, a.AUGDT, a.LIFNR ORDER BY a.BLDAT, a.BELNR, a.BUZEI) RUNNINGSUM_PAGAMENTO,
		SUM(A.WRSHB) OVER (PARTITION BY  a.BUKRS, a.AUGBL, a.AUGDT, a.LIFNR ORDER BY a.BLDAT, a.BELNR, a.BUZEI) RUNNINGSUM_PAGAMENTO_LC,
		BLDAT
		FROM :WT_FOR_PASSO1 a
		inner join :M_CHIAVE_CONTABILE b
		on (a.BSCHL=b.BSCHL)
		where b.DESTINAZIONE='Fornitore'
		and b.TIPO_CHIAVE='Pagamenti'
		--Condizione da imputare
		--and rtrim(ltrim(isnull(AUGBL, '')))<>''
		and a.STATUS=0
	;
	
--Fatture
	TMP_Passo2_Fatture =
		select 
		ROW_NUMBER() over (order by a.AUGBL, a.AUGDT, a.LIFNR, a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI) as "ROWID",
		a.BSCHL,
		--Documenti di Pareggio
		AUGBL, AUGDT, LIFNR, 
		--Chiave contabile
		a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI,
		--Valori del pagamento
		A.DMSHB + ifnull(a.VAL_PAGATO_ALLOCATO, 0) as "VAL_FATTURA", 
		A.WRSHB + ifnull(a.VAL_PAGATO_ALLOCATO_LC, 0) as "VAL_FATTURA_LC",
		--Running Sum
		SUM(A.DMSHB + ifnull(a.VAL_PAGATO_ALLOCATO, 0)) OVER (PARTITION BY  a.BUKRS, a.AUGBL, a.AUGDT, a.LIFNR ORDER BY a.BLDAT, a.BELNR, a.BUZEI) RUNNINGSUM_FATTURA,
		SUM(A.WRSHB + ifnull(a.VAL_PAGATO_ALLOCATO_LC, 0)) OVER (PARTITION BY  a.BUKRS, a.AUGBL, a.AUGDT, a.LIFNR ORDER BY a.BLDAT, a.BELNR, a.BUZEI) RUNNINGSUM_FATTURA_LC,
		BLDAT, NETDT
		FROM :WT_FOR_PASSO1 a
		inner join :M_CHIAVE_CONTABILE b
		on (a.BSCHL=b.BSCHL)
		left join :TMP_Passo2_Fatture_Elise c
		on (a.BUKRS=c.BUKRS and a.GJAHR=c.GJAHR and a.BELNR=c.BELNR and a.BUZEI=c.BUZEI)
		where b.DESTINAZIONE='Fornitore'
		and b.TIPO_CHIAVE='Fatture'
		--Condizione da imputareand rtrim(ltrim(isnull(AUGBL, '')))<>''
		and a.STATUS=0
		and c.BUKRS is null	
	;
	
	--seleziono per ogni fattura il minimo running sum di pagamenti che copra il runningsum delle fatture

	--Passo1: seleziono tutte le fatture associate almeno ad un pagamento
	TMP_Passo2_P0_A = 
		select 
		--a.ROWID NUMROW_FATTURA, b.ROWID NUMROW_PAGAMENTO, RUNNINGSUM_FATTURA, abs(RUNNINGSUM_PAGAMENTO)
		a.AUGBL, a.AUGDT, a.LIFNR, a."ROWID" NUMROW_FATTURA, min(b."ROWID") as "NUMROW_PAGAMENTO"
		from :TMP_Passo2_Fatture a 
		inner join :TMP_Passo2_Pagamenti b
		on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.BUKRS=b.BUKRS and a.LIFNR=b.LIFNR)
		where RUNNINGSUM_FATTURA<=abs(RUNNINGSUM_PAGAMENTO)
		group by a.AUGBL, a.AUGDT, a.LIFNR, a."ROWID"
		order by 1 
	;
	
	
	--Passo2: Per tutte le fatture non presenti all'interno dela passo1, seleziono la prima e la associo automaticamente al pagamento maggiore possibile
		--> viene coperta solo parzialmente, quindi prendo la più vecchia
	TMP_Passo2_P0 = 
		(select AUGBL, AUGDT, LIFNR, NUMROW_FATTURA, NUMROW_PAGAMENTO
			from :TMP_Passo2_P0_A)
		union all 
		(select a.AUGBL, a.AUGDT, a.LIFNR, min(a."ROWID") NUMROW_FATTURA, max(b."ROWID") NUMROW_PAGAMENTO
		from :TMP_Passo2_Fatture a 
		inner join :TMP_Passo2_Pagamenti b
		on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.BUKRS=b.BUKRS and a.LIFNR=b.LIFNR)
		left join :TMP_Passo2_P0_A c
		on (a."ROWID"=c.NUMROW_FATTURA)
		where c.NUMROW_FATTURA is null
		group by a.AUGBL, a.AUGDT, a.LIFNR
		order by 1,2)
		;
	
 
	--Seleziono per ogni rigafattura, il runningsum del valore precedente
	TMP_Passo2_P1 = 
	select a.AUGBL, a.AUGDT, a.LIFNR, a.NUMROW_FATTURA, a.NUMROW_PAGAMENTO, max(b.NUMROW_FATTURA) FATTURA_LESS1, max(b.NUMROW_PAGAMENTO) PAGAMENTO_LESS1
	From :TMP_Passo2_P0 a
	left join :TMP_Passo2_P0 b
	on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.NUMROW_FATTURA>b.NUMROW_FATTURA and a.LIFNR=b.LIFNR)
	group by a.AUGBL, a.AUGDT, a.LIFNR, a.NUMROW_FATTURA, a.NUMROW_PAGAMENTO
	;

	--Gestisco gli intervalli di pagamento
	TMP_Passo2_P2 = 
	select ROW_NUMBER() over (order by a.NUMROW_FATTURA, NUMROW_PAGAMENTO) "ROWID", a.*
	from
	(
		select a.AUGBL, a.AUGDT, a.LIFNR, a.NUMROW_FATTURA, ifnull(b."ROWID", c.MINROWID) NUMROW_PAGAMENTO
		from :TMP_Passo2_P1 a
		join 
		(
			--Per ogni documento di pareggio devo gestire il minimo documento contabile di pagamento (lowerbound)
			select AUGBL, AUGDT, LIFNR, min ("ROWID") MINROWID
			from :TMP_Passo2_Pagamenti
			group by AUGBL, AUGDT, LIFNR
		) c
		on (a.AUGBL=c.AUGBL and a.AUGDT=c.AUGDT)
		left join :TMP_Passo2_Pagamenti b
		on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR and b."ROWID" between ifnull(a.PAGAMENTO_LESS1 , c.MINROWID) and a.NUMROW_PAGAMENTO)
		
	) a
	;

	--Seleziono per ogni rigafattura, il runningsum del valore precedente
	TMP_Passo2_P3 = 
	select a.AUGBL, a.AUGDT, a.LIFNR, a.NUMROW_FATTURA, a.NUMROW_PAGAMENTO, max(b.NUMROW_FATTURA) FATTURA_LESS1, max(b.NUMROW_PAGAMENTO) PAGAMENTO_LESS1
	From :TMP_Passo2_P2 a
	left join :TMP_Passo2_P2 b
	on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR AND a."ROWID">b."ROWID")
	group by a.AUGBL, a.AUGDT, a.LIFNR, a.NUMROW_FATTURA, a.NUMROW_PAGAMENTO
	;
	
	TMP_Passo2_P4 = 
	select  a.AUGBL, a.AUGDT, a.LIFNR, a.NUMROW_FATTURA, a.FATTURA_LESS1 NUMROW_FATTURA_LESS1, a.NUMROW_PAGAMENTO, a.PAGAMENTO_LESS1 NUMROW_PAGAMENTO_LESS1,
	b.VAL_FATTURA, b.RUNNINGSUM_FATTURA, c.VAL_PAGAMENTO, c.RUNNINGSUM_PAGAMENTO, ifnull("d"."RUNNINGSUM_FATTURA", 0) RUNNINGSUM_FATTURA_LESS1,
	b.VAL_FATTURA_LC, b.RUNNINGSUM_FATTURA_LC, c.VAL_PAGAMENTO_LC, c.RUNNINGSUM_PAGAMENTO_LC, ifnull("d"."RUNNINGSUM_FATTURA_LC", 0) RUNNINGSUM_FATTURA_LC_LESS1
	from :TMP_Passo2_P3 a
	inner join :TMP_Passo2_Fatture b
	on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR and a.NUMROW_FATTURA=b."ROWID")
	inner join :TMP_Passo2_Pagamenti c
	on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR and a.NUMROW_PAGAMENTO=c."ROWID")
	left join :TMP_Passo2_Fatture as "d"
	on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR and a.FATTURA_LESS1= "d"."ROWID")
	;
	
	--Generiamo il max rowid per ogni fattura
	Temp_Fatture = 
	select BUKRS, GJAHR, BELNR, BUZEI, ifnull(max("ROWID"), 0) MAX_ROWID
	From :WT_FOR_PASSO1
	group by BUKRS, GJAHR, BELNR, BUZEI
	;
	
	--Generiamo il valore della tabella
	TMP_Passo2_P5_s1 =
	(select BUKRS, GJAHR, BELNR, BUZEI, "ROWID", 
	a.LIFNR,
	a.BSCHL,
	a.BLDAT, a.NETDT,
	DMSHB,
	WRSHB,
	VAL_PAGATO_ALLOCATO_GMP, 
	VAL_PAGATO_ALLOCATO_GMP_LC, 
	DATA_PAGAMENTO, 
	ESERCIZIO_PAGAMENTO,
	DOCUMENTO_PAGAMENTO,
	NUM_RIGA_PAGAMENTO,
	null AUGBL, 
	null AUGDT,
	null DATA_PAREGGIO
	from :WT_FOR_PASSO1 a
	inner join :M_CHIAVE_CONTABILE b
	on (a.BSCHL=b.BSCHL)
	where a."ROWID" is not null --Fatture già elaborate
	and  b.DESTINAZIONE='Fornitore'
	and b.TIPO_CHIAVE='Fatture')
		union all
	--Pagamenti elaborati in questo giro
	(select a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI, 1 "ROWID", 
	a.LIFNR,
	a.BSCHL,
	a.BLDAT, a.NETDT,
	DMSHB,
	WRSHB,
	VAL_PAGATO_ALLOCATO_GMP, 
	VAL_PAGATO_ALLOCATO_GMP_LC, 
	DATA_PAGAMENTO, 
	null ESERCIZIO_PAGAMENTO,
	null DOCUMENTO_PAGAMENTO,
	null NUM_RIGA_PAGAMENTO,
	a.AUGBL, 
	a.AUGDT,
	null DATA_PAREGGIO
	from :WT_FOR_PASSO1 a
	inner join 
	:TMP_Passo2_Pagamenti b
	on (a.BUKRS=b.BUKRS and a.GJAHR=b.GJAHR and a.BELNR=b.BELNR and a.BUZEI=b.BUZEI)
	join :M_CHIAVE_CONTABILE c
	on (a.BSCHL=c.BSCHL)
	where c.DESTINAZIONE='Fornitore'
	and c.TIPO_CHIAVE='Pagamenti')
		union
	--Pagamenti elaborati nel giro precedente
	(select a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI, 1 "ROWID", 
	a.LIFNR,
	a.BSCHL,
	a.BLDAT, a.NETDT,
	DMSHB,
	WRSHB,
	VAL_PAGATO_ALLOCATO_GMP, 
	VAL_PAGATO_ALLOCATO_GMP_LC, 
	DATA_PAGAMENTO, 
	null ESERCIZIO_PAGAMENTO,
	null DOCUMENTO_PAGAMENTO,
	null NUM_RIGA_PAGAMENTO,
	null AUGBL, 
	null AUGDT,
	null DATA_PAREGGIO
	from :WT_FOR_PASSO1 a
	join :M_CHIAVE_CONTABILE c
	on (a.BSCHL=c.BSCHL)
	where c.DESTINAZIONE='Fornitore'
	and c.TIPO_CHIAVE='Pagamenti'
	and a.STATUS=1)
	;
	
	tmp_mc_test = 
	select 
	BUKRS, GJAHR, BELNR, BUZEI, "ROWID",
	LIFNR,
	BSCHL,
	BLDAT, 
	NETDT,
	case when "ROWID"=1 then VAL_FATTURA else 0 end VAL_FATTURA,
	case when "ROWID"=1 then VAL_FATTURA_LC else 0 end VAL_FATTURA_LC,
	VAL_PAGATO_ALLOCATO_GMP,
	VAL_PAGATO_ALLOCATO_GMP_LC,
	DATA_PAREGGIO DATA_PAGAMENTO, 
	ESERCIZIO_PAGAMENTO,
	DOCUMENTO_PAGAMENTO,
	NUM_RIGA_PAGAMENTO,
	AUGBL, 
	AUGDT,
	DATA_PAREGGIO
	from 
	(
		select 
		b.BUKRS, b.GJAHR, b.BELNR, b.BUZEI, ROW_NUMBER() over (partition by NUMROW_FATTURA order by a.NUMROW_PAGAMENTO) +d.MAX_ROWID "ROWID",
		b.LIFNR,
		b.BSCHL,
		b.BLDAT, b.NETDT,
		b.VAL_FATTURA,
		b.VAL_FATTURA_LC,
		--NUMROW_FATTURA, NUMROW_PAGAMENTO, 
		case
			when ifnull(a.NUMROW_FATTURA_LESS1, -1)=a.NUMROW_FATTURA and a.RUNNINGSUM_FATTURA<=abs(a.RUNNINGSUM_PAGAMENTO) then -1*(a.RUNNINGSUM_FATTURA-abs(a.RUNNINGSUM_PAGAMENTO)+abs(a.VAL_PAGAMENTO))
			else
				case
					when ifnull(a.NUMROW_FATTURA_LESS1, -1)<>a.NUMROW_FATTURA and a.RUNNINGSUM_FATTURA<=abs(a.RUNNINGSUM_PAGAMENTO) then -1*a.VAL_FATTURA
					else 
						case
							when a.NUMROW_PAGAMENTO=a.NUMROW_PAGAMENTO_LESS1 and a.RUNNINGSUM_FATTURA>=abs(a.RUNNINGSUM_PAGAMENTO) then -1*(abs(a.RUNNINGSUM_PAGAMENTO)-a.RUNNINGSUM_FATTURA_LESS1)
							else a.VAL_PAGAMENTO
						end
				end
		end VAL_PAGATO_ALLOCATO_GMP,
		case
			when ifnull(a.NUMROW_FATTURA_LESS1, -1)=a.NUMROW_FATTURA and a.RUNNINGSUM_FATTURA_LC<=abs(a.RUNNINGSUM_PAGAMENTO_LC) then -1*(a.RUNNINGSUM_FATTURA_LC-abs(a.RUNNINGSUM_PAGAMENTO_LC)+abs(a.VAL_PAGAMENTO_LC))
			else
				case
					when ifnull(a.NUMROW_FATTURA_LESS1, -1)<>a.NUMROW_FATTURA and a.RUNNINGSUM_FATTURA_LC<=abs(a.RUNNINGSUM_PAGAMENTO_LC) then -1*a.VAL_FATTURA_LC
					else 
						case
							when a.NUMROW_PAGAMENTO=a.NUMROW_PAGAMENTO_LESS1 and a.RUNNINGSUM_FATTURA_LC>=abs(a.RUNNINGSUM_PAGAMENTO_LC) then -1*(abs(a.RUNNINGSUM_PAGAMENTO_LC)-a.RUNNINGSUM_FATTURA_LC_LESS1)
							else a.VAL_PAGAMENTO
						end
				end
		end VAL_PAGATO_ALLOCATO_GMP_LC,
		c.GJAHR ESERCIZIO_PAGAMENTO,
		c.BELNR DOCUMENTO_PAGAMENTO,
		c.BUZEI NUM_RIGA_PAGAMENTO,
		c.AUGBL, 
		c.AUGDT,
		c.BLDAT DATA_PAREGGIO
		--into WT_FOR_PASSO2
		from :TMP_Passo2_P4 a
		join :TMP_Passo2_Fatture b
		on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR and a.NUMROW_FATTURA=b."ROWID")
		join :TMP_Passo2_Pagamenti c
		on (a.AUGBL=b.AUGBL and a.AUGDT=b.AUGDT and a.LIFNR=b.LIFNR and a.NUMROW_PAGAMENTO=c."ROWID")
		join :Temp_Fatture d
		on (b.BUKRS=d.BUKRS and b.GJAHR=d.GJAHR and b.BELNR=d.BELNR and b.BELNR=d.BELNR))
	;
	
	TMP_Passo2_P5 = 
		(select * from :TMP_Passo2_P5_s1) 
			union
		(select * from :tmp_mc_test)
		order by 1,2,3,4,5
		;
	
	return  
		(select 
		a.BUKRS, a.GJAHR, a.BELNR, a.BUZEI, a."ROWID", 
		a.LIFNR,
		a.BSCHL,
		case
			when a.DMSHB=abs(VAL_PAGATO_ALLOCATO) then 1 --Fatture totalmente elise dai documenti di pareggio
			when a."ROWID">1 then 1 --Righe fatture fittizie generate con il passo2
			else 0
		end STATUS, 
		a.BLDAT, a.NETDT,
		case when a."ROWID"=1 then a.DMSHB else 0 end DMSHB,
		case when a."ROWID"=1 then a.WRSHB else 0 end WRSHB,
		case when a."ROWID"=1 then b.VAL_PAGATO_ALLOCATO else null end VAL_PAGATO_ALLOCATO,
		a.VAL_PAGATO_ALLOCATO_GMP, 
		case when a."ROWID"=1 then b.VAL_PAGATO_ALLOCATO_LC else null end VAL_PAGATO_ALLOCATO_LC,
		a.VAL_PAGATO_ALLOCATO_GMP_LC, 
		a.DATA_PAGAMENTO, 
		a.ESERCIZIO_PAGAMENTO,
		a.DOCUMENTO_PAGAMENTO,
		a.NUM_RIGA_PAGAMENTO,
		a.AUGBL,
		a.AUGDT,
		b.DATA_PAREGGIO
		from :TMP_Passo2_P5 a
		left join
		(
			select BUKRS, GJAHR, BELNR, BUZEI, a.BSCHL, b.TIPO_CHIAVE,
			case 
				when b.TIPO_CHIAVE='Fatture' then sum(VAL_PAGATO_ALLOCATO_GMP) 
				else -1*sum(a.DMSHB)
			end VAL_PAGATO_ALLOCATO, 
			case 
				when b.TIPO_CHIAVE='Fatture' then sum(VAL_PAGATO_ALLOCATO_GMP_LC) 
				else -1*sum(a.WRSHB)
			end VAL_PAGATO_ALLOCATO_LC, 
			max(DATA_PAREGGIO) DATA_PAREGGIO
			From :TMP_Passo2_P5 a
			join :M_CHIAVE_CONTABILE b
			on (a.BSCHL=b.BSCHL)
			group by BUKRS, GJAHR, BELNR, BUZEI, a.BSCHL, b.TIPO_CHIAVE
		) b
		on (a.BUKRS=b.BUKRS and a.GJAHR=b.GJAHR and a.BELNR=b.BELNR and a.BUZEI=b.BUZEI and a.BSCHL=b.BSCHL))
 	;
 	
 
END;